# -*- coding: utf-8 -*-
import os
import sys
import json
import random
import re
import base64
import shutil
from io import BytesIO
import html 
import aiohttp
import nest_asyncio

from flask import Flask
from telegram.constants import ChatAction
from threading import Thread
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.helpers import mention_html, escape_markdown
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)

import logging

# Logger setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
nest_asyncio.apply()




TOKEN = "8323659076:AAE4vDWIPxPxesfgYv5be5qHPQymxP8qDoA"
OWNER_USERNAME = "@Lord_MentorRainn"
OWNER_ID = 7507031482
CHANNEL_ID = -1002153191249  
GROUP_ID = -1001234567890  # á€á€„á€·á€º group id
GROUP_ID_FILE = "group_id.txt"
LOG_FILE = "send_logs.json"
MAX_LOGS = 5000
GROUP_FILE = "groups.json"
ADMIN_FILE = "admins.json"
ADMIN_IDS = [7808603044, 987654321] 
# Default group IDs (empty for now)
# Default admin user IDs
DEFAULT_ADMINS = [
    
]

ADMINS = set(DEFAULT_ADMINS)


# ===== Runtime Variables =====
ADMINS = set(DEFAULT_ADMINS)
BANNED_ADMINS = set()

ACTIVE_ATTACKS = {}
attacking_users = {}  # chat_id -> set of targets
attack_tasks = {}
secret_attack_targets = set()
attack_targets = {}
attack_speed = 0.3 # default delay in seconds
hidden_targets = set()  # hidden/secret attack mode
active_fight_sessions = {}  # chat_id: {user1_id: user2_id, user2_id: user1_id}
user_limits = {}  # username_lower: remaining uses
nicknames = {}  # user_id: nickname

# Offensive auto-replies
auto_replies = [ "á€•á€¼á€á€¬á€”á€¬á€†á€­á€¯á€á€²á€·á€á€á€„á€ºá€†á€²á€›á€„á€ºá€™á€„á€ºá€¸á€á€­á€¯á€·á€„á€¼á€­á€™á€ºá€á€¶á€›á€™á€šá€ºá€†á€­á€¯á€á€¬á€™á€„á€ºá€¸á€á€­á€¯á€·á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€¼á€®á€¸á€™á€á€„á€ºá€•á€±á€¸á€‘á€¬á€¸á€˜á€°á€¸á€œá€¬á€¸", "á€™á€„á€ºá€¸á€¡á€–á€±á€€á€•á€­á€¯á€€á€ºá€†á€¶á€œá€­á€¯á€œá€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€„á€«á€”á€²á€·á€•á€±á€¸á€œá€­á€¯á€¸á€•á€¼á€®á€¸á€™á€„á€ºá€¸á€‘á€½á€€á€ºá€œá€¬á€á€¬á€œá€±á€á€¬á€¸á€™á€­á€¯á€€á€º", "á€™á€„á€ºá€¸á€…á€±á€¬á€ºá€–á€¬á€á€Šá€ºá€™á€•á€±á€¸á€˜á€¯á€•á€«á€œá€¬á€¸á€œá€½á€á€ºá€œá€­á€¯á€€á€ºâ€Œá€±á€”á€¬á€ºá€¡á€›á€¾á€„á€ºá€á€á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€®á€€á€­á€¯á€œá€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯á€„á€«á€·á€†á€®á€œá€­á€„á€ºá€€á€»á€½á€”á€ºá€¡á€–á€¼á€…á€ºá€á€…á€¬á€¸á€”á€±á€›á€á€šá€º", "á€˜á€¬á€˜á€¬á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€á€šá€ºá€Ÿá€¯á€á€ºá€œá€¬á€¸ á€á€¼á€±á€‘á€±á€¬á€€á€ºá€‘á€­á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€œá€±", "á€Ÿá€€á€ºá€€á€œá€…á€ºá€á€½á€±á€¸á€™á€„á€ºá€¸á€€á€œá€…á€ºá€€á€¼á€®á€¸á€€á€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€˜á€²Typingá€†á€­á€¯á€›á€„á€ºá€á€±á€¬á€·á€œá€­á€•á€ºá€‚á€½á€„á€ºá€¸á€‘á€¯á€™á€¾á€•á€¼á€®á€¸á€™á€šá€·á€ºá€€á€±á€¬á€„á€º", "á€„á€«á€›á€²á€·á€…á€¬á€€á€­á€¯á€á€»á€±á€•á€–á€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€¼á€®á€¸á€€á€™á€á€„á€ºá€•á€±á€¸á€‘á€¬á€¸á€˜á€°á€¸á€œá€±á€€á€½á€¬", "á€™á€„á€ºá€¸á€…á€€á€±á€¸á€€á€’á€«á€•á€²á€œá€¬á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€€á€­á€¯á€€á€ºá€¡á€¯á€”á€ºá€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€€á€¼á€±á€¬á€€á€ºá€€á€”á€ºá€€á€”á€ºá€á€¬á€œá€¬á€¸á€¡á€€á€ºá€á€¬á€€", "á€˜á€¬á€á€½á€±á€•á€¼á€±á€¬á€”á€±á€á€¬á€’á€®á€…á€±á€¬á€€á€ºá€›á€°á€¸á€‚á€±á€«á€€á€ºá€á€®á€¸á€”á€²á€·á€€á€á€±á€¬á€·", "á€•á€¼á€±á€¬á€á€»á€„á€ºá€á€¬á€á€½á€±á€•á€¼á€±á€¬á€•á€®á€á€…á€ºá€€á€­á€¯á€šá€ºá€á€±á€¬á€„á€ºá€œá€½á€á€ºá€•á€»á€±á€¬á€ºá€”á€±á€á€¬á€œá€¬á€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸á€œá€±á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€€á€»á€•á€ºá€™á€•á€¼á€Šá€·á€ºá€˜á€°á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€›á€„á€ºá€€á€½á€²á€™á€œá€¬á€¸", "á€™á€„á€ºá€¸á€”á€¬á€™á€Šá€ºá€€á€™á€¡á€±á€¸á€œá€­á€¯á€¸á€•á€±á€«á€·", "á€™á€„á€ºá€¸á€€á€˜á€¬á€œá€­á€¯á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€–á€¼á€…á€ºá€”á€±á€›á€á€¬", "á€šá€»á€±á€¬á€„á€·á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€„á€«á€™á€±á€¸á€”á€±á€á€šá€º", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€˜á€šá€ºá€•á€¼á€±á€¸á€™á€¾á€¬á€•á€¼á€”á€ºá€œá€¬á€€á€­á€¯á€€á€º", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€á€±á€¬á€á€®á€¸á€•á€»á€±á€¬á€·á€á€»á€€á€ºá€€á€á€±á€¬á€·á€‚á€½á€±á€¸á€á€®á€¸á€œá€¬á€•á€²", "á€¡á€¬á€á€®á€¸á€šá€±á€¬á€„á€ºá€á€¬á€œá€»á€¾á€±á€¬á€·á€œá€­á€¯á€€á€ºá€á€±á€¬á€á€¬á€¸á€œá€±ğŸ‘ğŸ¤¨ğŸ¤¨", "Hiá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€…á€¬á€›á€­á€¯á€€á€ºá€•á€«á€¡á€¯á€”á€ºá€¸á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€¡á€”á€°á€œá€€á€ºá€”á€²á€·á€€á€¯á€œá€¬á€¸á€›á€±", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€¡á€á€¯á€™á€˜á€¬á€€á€­á€¯á€€á€°á€•á€«á€€á€šá€ºá€•á€«á€œá€²ğŸ˜³", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€›á€­á€¯á€€á€ºá€‘á€¬á€¸á€œá€±á€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸", "á€™á€¡á€±á€¸á€œá€­á€¯á€¸á€á€½á€±á€¸á€á€¬á€¸á€”á€¬á€¸á€›á€„á€ºá€„á€«á€·á€á€•á€Šá€·á€º", "á€„á€«á€·á€¡á€™á€­á€”á€·á€ºá€™á€›á€•á€²á€˜á€¬á€€á€­á€¯á€”á€¬á€¸á€á€»á€„á€ºá€á€¬á€œá€²á€á€½á€±á€¸á€™á€á€¬á€¸á€™á€»á€­á€¯á€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€–á€®á€†á€”á€ºá€á€¬á€œá€¬á€¸á€€á€½ğŸ˜¨", "á€™á€€á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸á€á€½á€±á€¸á€™á€á€¬á€¸ğŸ˜", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€Šá€±á€¬á€„á€ºá€¸á€”á€±á€•á€®á€œá€¬á€¸", "á€™á€„á€ºá€¸á€œá€€á€ºá€á€½á€±á€€á€¡á€œá€¯á€•á€ºá€€á€¼á€™á€ºá€¸á€œá€¯á€•á€ºá€á€²á€·á€œá€€á€ºá€•á€²á€˜á€¬á€€á€­á€¯á€Šá€±á€¬á€„á€ºá€¸á€á€»á€„á€ºá€šá€±á€¬á€„á€ºá€†á€±á€¬á€„á€ºá€á€¬á€œá€²", "á€Ÿá€”á€ºá€•á€²á€›á€¾á€­á€á€šá€ºâ€Œá€™á€¬á€”á€ºá€™á€›á€¾á€­á€˜á€°á€¸á€™á€„á€ºá€¸á€œá€­á€¯á€á€½á€±á€¸á€€ğŸ˜›", "á€˜á€¬á€†á€„á€ºá€á€¼á€±á€á€½á€±á€œá€¬á€•á€±á€¸á€”á€±á€á€¬á€™á€á€”á€¬á€¸á€˜á€°á€¸á€„á€«á€€", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€€á€¼á€±á€¬á€„á€ºá€á€±á€¬á€„á€ºá€á€±á€¬á€„á€ºá€”á€²á€·á€›á€°á€¸á€”á€±á€á€¬á€œá€¬á€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€€á€­á€¯á€€á€ºá€œá€±á€™á€„á€ºá€¸á€¡á€™á€±á€…á€±á€¬á€€á€ºá€•á€á€ºá€™á€œá€­á€¯á€·á€”á€¬á€¸á€á€¬á€œá€¬á€¸á€™á€„á€ºá€¸á€€", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€á€²á€·á€…á€±á€¬á€€á€ºá€•á€»á€±á€¬á€·á€œá€°á€œá€¬á€¸á€á€½á€±á€¸á€œá€¬á€¸á€™á€„á€ºá€¸á€€á€™á€á€²á€€á€½á€²á€á€±á€¬á€·á€˜á€°á€¸", "á€™á€„á€ºá€¸á€™á€­á€˜á€„á€«á€œá€­á€¯á€¸á€„á€«á€œá€­á€¯á€¸á€™á€½á€±á€¸á€‘á€¬á€¸á€á€²á€·á€á€¬á€¸á€•á€²á€™á€„á€ºá€¸á€€", "á€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€œá€­á€¯á€¸á€œá€­á€¯á€€á€ºá€œá€­á€¯á€·á€™á€„á€ºá€¸á€€á€„á€«á€·á€á€¬á€¸á€–á€¼á€…á€ºá€€á€±á€¬á€œá€¬á€¸á€á€±á€¬á€á€®á€¸ğŸ¤‘", "á€á€±á€¬á€á€®á€¸á€™á€”á€¬á€¸á€”á€²á€·á€œá€±á€€á€­á€¯á€€á€ºá€¡á€½á€™á€ºá€¸", "á€•á€»á€±á€¬á€·á€œá€­á€¯á€€á€ºá€á€¬á€€á€½á€¬á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€’á€°á€’á€°á€’á€”á€ºá€’á€”á€ºá€€á€±á€¬á€„á€º", "á€á€­á€•á€«á€•á€¼á€®á€á€­á€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€†á€­á€¯á€á€¬", "á€Ÿá€±á€·á€›á€±á€¬á€„á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸á€¡á€á€¯á€™á€¾á€€á€°á€•á€«á€€á€šá€ºá€•á€«á€’á€°á€•á€«á€’á€”á€ºá€•á€«á€œá€¯á€•á€ºá€”á€±á€á€¬á€œá€¬á€¸á€™á€»á€€á€ºá€”á€¾á€¬á€œá€­á€¯á€™á€»á€€á€ºá€”á€¾á€¬á€›á€„á€«á€·á€˜á€±á€¬á€¡á€á€„á€ºá€¸á€€á€•á€ºá€™á€•á€¼á€®á€¸á€™á€¾á€¡á€á€¯á€˜á€¬á€•á€¼á€”á€ºá€€á€­á€¯á€€á€ºá€á€»á€„á€ºá€”á€±á€á€¬á€œá€Šá€ºá€¸á€Ÿá€±á€·á€›á€±á€¬á€„á€ºá€á€½á€±á€¸á€á€°á€á€±á€¬á€„á€ºá€¸á€…á€¬á€¸", "á€›á€¯á€•á€ºá€†á€­á€¯á€¸á€™á€á€¬á€¸á€á€±á€á€»á€„á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€†á€›á€¬á€á€á€„á€ºá€•á€¼á€á€¬á€”á€¬á€€á€­á€¯á€¡á€²á€·á€œá€­á€¯á€€á€•á€ºá€á€­á€¯á€¸á€œá€±á€¸á€˜á€±á€¬á€™á€›á€¯á€¶á€”á€²á€·á€á€±á€¬á€·á€™á€›á€˜á€°á€¸", "á€™á€„á€ºá€¸á€€á€œá€°á€á€€á€¬á€˜á€±á€¬á€™á€œá€¬á€¸á€˜á€¬á€œá€­á€¯á€·á€›á€±á€¬á€á€¬á€œá€²", "á€œá€½á€šá€ºá€œá€­á€¯á€€á€ºá€á€¬á€€á€½á€¬á€¡á€”á€­á€¯á€„á€ºá€šá€°á€™á€­á€•á€¼á€”á€ºá€•á€®ğŸ˜", "á€¡á€²á€·á€œá€±á€¬á€€á€ºá€‡á€”á€²á€·á€™á€”á€­á€¯á€„á€ºá€á€±á€¸á€˜á€°á€¸á€™á€„á€ºá€¸á€„á€«á€·á€€á€­á€¯", "á€€á€¼á€­á€¯á€¸á€…á€¬á€¸á€¡á€¯á€”á€ºá€¸á€á€¬á€¸á€–á€±á€¬á€€á€ºá€œá€­á€¯á€á€±á€¸á€á€šá€º", "á€šá€»á€±á€¬á€„á€·á€ºá€¡á€€á€­á€¯á€€á€ºá€Šá€¶á€·á€á€²á€·á€á€½á€±á€¸á€˜á€šá€ºá€”á€±á€›á€¬á€á€„á€ºá€•á€¯á€”á€ºá€¸á€•á€¼á€”á€ºá€•á€®á€œá€²", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€™á€€á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸", "á€™á€„á€ºá€¸á€œá€±á€¬á€€á€ºá€•á€»á€±á€¬á€·á€á€¬á€™á€„á€ºá€¸á€•á€²á€›á€¾á€­á€á€šá€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€¡á€¯á€”á€ºá€¸á€™á€…á€¬á€¸á€”á€²á€·á€á€±á€¬á€á€®á€¸á€›á€¯á€”á€ºá€¸á€™á€¾á€¬á€á€¬á€†á€€á€ºá€›á€¯á€”á€ºá€¸", "á€€á€¼á€±á€¬á€€á€ºá€”á€±á€á€¬á€œá€¬á€¸á€™á€„á€ºá€¸á€€", "á€˜á€¬á€œá€­á€¯á€·á€€á€¼á€±á€¬á€€á€ºá€•á€¼á€”á€±á€á€¬á€œá€²á€á€½á€±á€¸á€œá€±á€¸", "á€™á€»á€€á€ºá€”á€¾á€¬á€„á€šá€ºá€œá€±á€¸á€”á€²á€·á€¡á€á€”á€¬á€¸á€á€¶á€á€±á€¬á€·á€™á€¬á€œá€¬á€¸", "á€á€±á€¸á€á€±á€¸á€€á€€á€­á€¯á€€á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€…á€®á€€á€¡á€”á€¶á€™á€€á€±á€¬á€„á€ºá€¸á€˜á€°á€¸", "á€á€½á€±á€¸á€”á€¶á€‘á€½á€€á€ºá€”á€±á€á€šá€ºá€á€½á€±á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€€", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€˜á€šá€ºá€€á€­á€¯á€•á€¼á€±á€¸á€™á€¬", "á€á€±á€¬á€á€¬á€¸á€€á€­á€¯á€€á€ºá€•á€«á€¡á€¯á€”á€ºá€¸á€¡á€šá€¬á€¸á€™á€•á€¼á€±á€–á€¼á€…á€ºá€”á€±á€á€šá€º", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€›á€±á€™á€„á€ºá€¸á€›á€¯á€”á€ºá€¸á€€á€”á€ºá€”á€±á€›á€•á€®á€œá€¬á€¸á€Ÿ", "á€™á€„á€ºá€¸á€™á€±á€…á€•á€á€½á€±á€á€„á€ºá€•á€¼á€±á€¬á€”á€±á€á€¬á€œá€¬á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€¡á€±á€¸á€¡á€²á€·á€á€±á€¬á€·á€™á€„á€ºá€¸á€€á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€•á€±á€«á€·á€Ÿá€¯á€á€ºá€œá€¬á€¸", "á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€†á€›á€¬á€•á€¼á€á€¬á€”á€¬á€€á€­á€¯á€¡á€›á€¾á€¯á€¶á€¸á€•á€±á€¸á€•á€®á€•á€±á€«á€·", "á€„á€«á€œá€­á€¯á€¸á€™á€á€±á€¬á€á€®á€¸á€›á€¾á€¯á€¶á€¸á€”á€±á€á€±á€¬á€·á€™á€»á€€á€ºá€”á€¾á€¬á€€á€á€…á€ºá€™á€»á€­á€¯á€¸", "á€†á€›á€¬Problemá€¡á€›á€¾á€­á€”á€ºá€¡á€á€«á€€á€á€±á€¬á€ºá€›á€¯á€¶á€™á€»á€€á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€€á€¼á€Šá€·á€ºá€™á€›á€˜á€°á€¸á€Šá€®", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€•á€¼á€”á€ºá€œá€­á€¯á€¸á€á€²á€·á€€á€­á€¯á€™á€±á€€á€­á€¯  á€œá€­á€¯á€¸á€á€¬á€¸á€•á€±á€«á€·á€™á€„á€ºá€¸á€€ğŸ˜³", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€€á€­á€¯á€šá€·á€ºá€¡á€™á€±á€€á€­á€¯á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€šá€ºá€œá€­á€¯á€·", "Sorry á€•á€²á€šá€–á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€„á€«á€œá€€á€ºá€œá€½á€”á€ºá€¡á€œá€­á€¯á€¸á€œá€½á€”á€ºá€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€›á€¾á€±á€¬á€•á€®", "á€™á€„á€ºá€¸á€•á€«á€¸á€…á€•á€ºá€€á€­á€¯á€–á€¼á€²á€•á€¼á€®á€¸ á€”á€¶á€Ÿá€±á€¬á€„á€ºá€”á€±á€á€šá€º á€¡á€¬á€•á€¯á€á€ºá€…á€±á€¬á€º á€•á€«á€¸á€…á€•á€ºá€€á€­á€¯ á€•á€­á€á€ºá€‘á€¬á€¸á€œá€­á€¯á€€á€º", "á€…á€…á€ºá€˜á€±á€¸á€›á€¾á€±á€¬á€„á€ºá€†á€­á€¯á€•á€¼á€®á€¸ á€›á€•á€ºá€€á€½á€•á€ºá€‘á€²á€™á€¾á€¬ á€•á€­á€¯á€€á€ºá€†á€¶á€œá€­á€¯á€€á€ºá€á€±á€¬á€„á€ºá€¸á€”á€±á€á€šá€º á€™á€á€¬á€€á€±á€¬á€„á€º", "á€˜á€±á€¬á€™", "á€™á€¡á€±á€œá€­á€¯á€¸á€œá€±á€¸á€™á€„á€ºá€¸á€™á€±á€–á€¬á€á€Šá€ºá€™á€†á€­á€¯á€á€¬á€œá€€á€ºá€á€¶á€œá€¬á€¸", "á€Ÿá€¯á€á€ºá€•á€«á€•á€¼á€®á€Ÿá€¯á€á€ºá€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€™á€±á€–á€¬á€á€Šá€ºá€™á€”á€¬á€›á€±á€¸á€œá€°á€…á€Šá€ºá€›á€²á€·á€œá€¬á€¸", "á€†á€„á€ºá€¸á€›á€²á€á€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€‘á€™á€„á€ºá€¸á€™á€á€»á€€á€ºá€€á€»á€½á€±á€¸á€”á€­á€¯á€„á€ºá€–á€°á€¸á€œá€¬á€¸", "á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€˜á€¬á€œá€­á€¯á€·á€›á€¾á€¯á€¶á€¸â€Œá€™á€²á€™á€²á€”á€±á€á€¬á€œá€Šá€ºá€¸", "á€„á€«á€œá€­á€°á€¸á€™á€á€¬á€¸á€á€€á€ºá€„á€¼á€­á€™á€ºá€€á€¯á€á€ºá€”á€±á€œá€¾á€á€»á€‰á€ºá€œá€¬á€¸", "á€™á€”á€­á€¯á€„á€ºá€›á€„á€ºá€á€±á€¬á€· left the group á€á€¬á€œá€¯á€•á€ºá€œá€­á€¯á€€á€ºá€á€±á€¬á€·á€Šá€®á€›á€±", "á€Ÿá€¬á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€¬á€á€€á€šá€ºá€–á€¼á€…á€ºá€”á€­á€¯á€„á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€˜á€¬á€œá€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯á€á€¶á€•á€¼á€±á€¬á€”á€±á€›á€á€¬á€œá€Šá€ºá€¸", "á€”á€¬á€¸á€™á€œá€Šá€ºá€˜á€°á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€²á€·á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€²á€·á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±á€€á€­á€¯á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€…á€¯á€¶á€›á€¾á€„á€ºá€¸á€•á€¼á€•á€±á€¸á€•á€«", "á€¡á€™á€¾á€”á€ºá€á€›á€¬á€¸á€›á€²á€·á€˜á€€á€ºá€á€±á€¬á€ºá€á€¬á€¸á€†á€­á€¯á€›á€„á€ºá€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€¡á€™á€¾á€”á€ºá€á€€á€šá€ºá€œá€­á€¯á€¸á€á€¬á€á€”á€ºá€á€¶á€•á€«", "á€™á€„á€ºá€¸á€…á€±á€¬á€€á€ºá€á€½á€€á€ºá€˜á€¬á€œá€­á€¯á€·á€™á€²á€”á€±á€á€¬", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€•á€±á€«á€€á€¼á€®á€¸á€á€…á€ºá€šá€±á€¬á€€á€ºá€‘á€²á€˜á€¬á€á€±á€•á€¼á€±á€¬", "á€€á€±á€¬á€„á€ºá€¸á€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€•á€¼á€®", "á€„á€«á€…á€­á€á€ºá€Šá€…á€ºá€”á€±á€á€šá€ºá€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€œá€®á€¸á€…á€¯á€•á€ºá€™á€€á€»á€½á€™á€ºá€¸á€œá€­á€¯á€·", "á€†á€€á€ºá€€á€­á€¯á€€á€ºá€•á€±á€¸á€•á€«á€˜á€±á€¬á€™á€›á€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€á€¯á€˜á€¡á€†á€„á€ºá€•á€¼á€±á€›á€²á€·á€œá€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€œá€°á€™á€²", "á€Ÿá€±á€¸á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€œá€€á€ºá€•á€”á€ºá€¸á€€á€»á€”á€±á€á€¬á€œá€¬á€¸", "á€™á€á€­á€á€»á€„á€ºá€˜á€°á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯ á€™á€„á€ºá€¸á€‰á€®á€¸á€œá€±á€¸á€œá€­á€¯á€¸á€”á€±á€•á€¼á€®", "á€™á€á€­á€á€»á€„á€ºá€˜á€°á€¸á€€á€½á€¬á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€œá€­á€¯á€€á€º", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€˜á€¬á€á€±á€•á€¼á€±á€¬", "á€œá€®á€¸á€•á€²á€†á€²á€”á€±á€á€¬á€á€±á€¬á€„á€ºá€¡á€“á€­á€•á€¹á€•á€¬á€šá€ºá€›á€¾á€­á€›á€¾á€­á€†á€²á€á€²á€·á€„á€«á€·á€€á€­á€¯á€¡á€¬á€¸á€€á€»á€…á€™á€ºá€¸á€•á€«á€Ÿ", "á€œá€°á€á€€á€¬á€¸á€œá€­á€¯á€¸á€á€¶á€›á€á€²á€·á€¡á€™á€±á€€á€”á€±á€™á€½á€±á€¸á€œá€¬á€á€²á€·á€á€¬á€¸", "á€€á€¼á€½á€€á€ºá€™á€á€¬á€¸", "á€Ÿá€­á€á€ºá€€á€±á€¬á€„á€º", "á€á€±á€™á€šá€ºá€”á€±á€¬á€º", "á€„á€«á€œá€­á€¯á€¸á€™á€á€€á€º", "á€œá€€á€ºá€á€½á€±á€á€¯á€”á€ºá€”á€±á€•á€¼á€®á€¸á€…á€¬á€á€½á€±á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€á€±á€¬á€·á€•á€«á€œá€¬á€¸á€Ÿ", "á€á€¯á€”á€ºá€›á€™á€šá€ºá€œá€± á€™á€„á€ºá€¸á€›á€„á€ºá€†á€­á€¯á€„á€ºá€”á€±á€›á€á€²á€·á€œá€°á€€ Problem  á€œá€±á€Šá€®", "á€™á€”á€±á€·á€á€”á€±á€·á€€á€™á€¾á€†á€­á€¯á€›á€¾á€šá€ºá€‘á€²á€á€„á€ºá€œá€¬á€•á€¼á€®á€¸á€¡á€›á€¾á€„á€ºá€˜á€¯á€›á€„á€ºá€€á€­á€¯á€•á€¯á€”á€ºá€€á€”á€ºá€á€¬á€á€±á€’á€á€ºá€”á€±á€¬á€ºá€á€½á€±á€¸á€›", "á€›á€¯á€€á€¹á€á€†á€­á€¯á€¸á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€„á€«á€œá€­á€¯á€¸ á€„á€«á€·á€œá€±á€¬á€€á€ºá€¡á€‘á€¬á€™á€€á€»á€œá€­á€¯á€·á€á€­á€¯á€¸á€„á€­á€¯á€”á€±á€á€¬á€œá€¬á€¸", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€…á€±á€¬á€€á€ºá€›á€¯á€•á€ºá€†á€­á€¯á€¸", "á€…á€±á€¬á€€á€ºá€¡á€‘á€¬á€€á€»á€”á€Šá€ºá€¸á€á€„á€ºá€•á€±á€¸á€™á€šá€ºá€–á€±á€–á€±á€á€±á€«á€º", "á€œá€®á€¸á€¦á€¸á€”á€¾á€±á€¬á€€á€ºá€”á€²á€·á€á€½á€±á€¸á€™á€€ á€œá€¬á€šá€¾á€¥á€ºá€”á€±á€á€¬", "á€‚á€»á€•á€­á€¯á€¸á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€¡á€­á€™á€ºâ€Œá€±á€™á€¼á€¬á€„á€ºá€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€€á€¼á€½á€€á€ºá€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€’á€­á€¯á€„á€ºá€†á€­á€¯á€†á€±á€¬á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€á€½á€±á€¸á€™á€»á€­á€¯á€¸á€á€¯á€¶á€¸á€á€¼á€„á€ºá€”á€±á€á€¬á€á€½á€±á€¸á€™á€€", "á€™á€¡á€±á€œá€­á€¯á€¸á€”á€¬á€‡á€®á€™á€á€¬á€¸", "á€šá€±á€›á€¾á€°á€€á€­á€¯á€¸á€€á€½á€šá€ºá€á€²á€·á€€á€¯á€œá€¬á€¸á€Ÿá€œá€®á€¸á€˜á€²", "á€˜á€¯á€›á€¬á€¸á€á€á€„á€ºá€œá€®á€¸á€€á€»á€½á€±á€¸á€•á€«á€…á€±", "á€™á€„á€ºá€¸á€€á€­á€¯á€€á€±á€¬á€„á€ºá€¸á€á€»á€®á€¸á€•á€±á€¸á€•á€¼á€®á€¸á€–á€„á€ºá€œá€­á€¯á€¸á€™á€¾á€¬á€œá€±á€…á€±á€¬á€€á€ºá€€á€¯á€œá€¬á€¸", "á€Ÿá€­á€á€ºá€á€€á€º á€”á€á€ºá€•á€¼á€Šá€ºá€á€¬á€á€á€­á€¶á€á€¬á€€ á€¡á€›á€¾á€„á€ºá€˜á€¯á€›á€„á€ºá€€á€¼á€½á€œá€¬á€•á€¼á€®á€–á€„á€ºá€œá€­á€¯á€¸á€á€±á€¬á€·á€™á€šá€ºá€Ÿá€™á€„á€ºá€¸á€€á€­á€¯", "á€„á€«á€œá€­á€¯á€¸á€¸á€™á€€á€¯á€œá€¬á€¸á€…á€¬á€‘á€•á€ºá€•á€­á€¯á€·á€›á€„á€ºá€¡á€á€­á€¯á€„á€ºá€¸á€…á€±", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€€á€¡á€á€­á€¯á€„á€ºá€¸á€…á€±á€œá€­á€¯á€·á€á€”á€ºá€á€¶á€á€¬á€Ÿá€„á€­á€„á€­", "á€á€€á€ºá€™á€á€¬á€¸á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€œá€±á€œá€®á€¸á€€á€¼á€Šá€·á€ºá€”á€±á€á€¬á€œá€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€½á€±á€¸á€†á€²á€›á€„á€ºá€„á€¼á€­á€™á€ºá€á€¶á€á€¯á€”á€ºá€™á€€á€­á€¯á€€á€ºá€”á€²á€·", "á€–á€„á€ºá€œá€­á€¯á€¸á€…á€á€”á€ºá€¸á€€á€•á€« á€Šá€®á€›á€±á€–á€„á€ºá€œá€­á€¯á€¸á€•á€«á€›á€…á€±", "á€–á€„á€ºá€œá€­á€¯á€¸á€á€½á€„á€·á€ºá€•á€¼á€¯á€•á€«", "á€™á€¡á€±á€œá€­á€¯á€¸á€€á€œá€²á€”á€²á€”á€²á€•á€²á€…á€›á€á€±á€¸á€á€šá€ºá€œá€±á€¬á€„á€ºá€”á€±á€˜á€®", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€­á€™á€ºá€œá€½á€¾á€á€ºá€œá€­á€¯á€€á€ºá€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€·á€œá€­á€„á€ºá€á€¶á€€á€¼á€®á€¸á€€á€­á€¯á€€á€¼á€­á€¯á€€á€ºá€”á€±á€á€¬á€™á€á€­á€˜á€°á€¸á€œá€¬á€¸", "á€œá€­á€•á€ºá€™á€á€¬á€¸á€œá€¬á€¸á€Ÿ", "á€œá€­á€•á€ºá€”á€²á€·á€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€‘á€½á€€á€ºá€œá€¬á€á€²á€·á€€á€±á€¬á€„á€ºá€€á€¼á€”á€±á€á€¬á€˜á€²", "á€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€•á€²á€…á€¬á€á€…á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€á€…á€ºá€œá€¯á€¶á€¸á€€", "á€™á€¡á€±á€œá€­á€¯á€¸á€œá€±á€¸á€›á€šá€ºá€™á€„á€ºá€¸á€…á€¬á€á€…á€ºá€€á€¼á€±á€¬á€„á€ºá€¸á€€á€„á€«á€·á€…á€¬á€œá€±á€¸á€€á€¼á€±á€¬á€„á€ºá€¸á€œá€±á€¬á€€á€ºá€‘á€½á€€á€ºá€á€šá€ºá€Ÿ", "á€á€½á€±á€¸á€™á€á€¬á€¸á€€á€œá€²á€„á€­á€¯á€–á€¼á€²á€–á€¼á€²á€–á€¼á€…á€ºá€”á€±á€˜á€®á€Ÿ", "á€á€€á€ºá€™á€œá€±á€¸á€€á€¯á€œá€¬á€¸á€™á€á€¬á€¸", "á€á€½á€±á€¸á€™á€á€¬á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€œá€²á€„á€«á€á€½á€±á€¸á€™á€á€¬á€¸á€†á€­á€¯á€•á€¼á€®á€¸á€‚á€¯á€á€ºá€šá€°á€”á€±á€™á€šá€·á€ºá€€á€±á€¬á€„á€ºá€•á€²á€Ÿ", "á€…á€¬á€œá€¯á€¶á€¸á€•á€±á€«á€„á€ºá€¸á€á€á€ºá€•á€¯á€¶á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€•á€²á€Ÿá€±á€¬á€„á€ºá€”á€±á€á€¬á€Ÿ", "á€á€½á€±á€¸á€™á€œá€±á€¸á€Ÿá€±á€¬á€„á€ºá€•á€¼", "á€á€±á€™á€šá€ºá€á€€á€ºá€™ á€™á€„á€ºá€¸á€¡á€™á€±á€á€€á€ºá€™á€€á€­á€¯á€…á€¬á€¸á€•á€¼", "á€™á€¡á€±á€œá€­á€¯á€¸á€›á€¯á€•á€ºá€€ á€•á€²á€›á€±á€•á€½á€€á€¼á€±á€¬á€ºá€•á€²á€…á€¬á€¸á€”á€±á€›á€á€²á€·á€…á€±á€¬á€€á€ºá€á€½á€€á€º", "á€€á€­á€¯á€€á€¼á€®á€¸á€á€­á€¯á€·á€œá€­á€¯ á€á€»á€­á€…á€ºá€˜á€¬á€‚á€« á€™á€¬á€œá€¬á€›á€¾á€™á€ºá€¸á€€á€±á€¬á€á€½á€± á€™á€á€šá€ºá€…á€¬á€¸á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯", "á€€á€¼á€€á€ºá€¥á€€á€¼á€±á€¬á€ºá€•á€²á€”á€±á€·á€á€­á€¯á€„á€ºá€¸á€…á€¬á€¸á€”á€±á€›á€á€¬á€†á€­á€¯á€†á€„á€ºá€¸á€›á€²á€á€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€•á€²á€Ÿá€„á€ºá€¸á€•á€²á€…á€¬á€¸á€›á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€á€Šá€œá€½á€á€ºá€œá€­á€¯á€€á€ºá€œá€± á€–á€¯á€”á€ºá€¸á€•á€¼á€„á€ºá€á€•á€±á€¸á€™á€šá€ºá€œá€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€™á€„á€ºá€¸á€–á€¯á€”á€ºá€¸á€™á€¾á€”á€ºá€€á€½á€²á€”á€±á€á€¬á€™á€•á€¼á€„á€ºá€•á€±á€¸á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯ á€•á€­á€¯á€€á€ºá€†á€¶á€™á€›á€¾á€­á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€–á€¯á€”á€ºá€¸á€™á€¾á€”á€ºá€€á€½á€²á€”á€±á€á€¬á€™á€œá€²á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯", "á€˜á€šá€ºá€œá€­á€¯á€œá€¯á€•á€ºá€™á€œá€²á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€œá€±á€¸á€™á€„á€ºá€¸á€¡á€†á€²á€á€¶á€”á€±á€›á€˜á€®á€Ÿ", "á€™á€¡á€±á€œá€­á€¯á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€†á€²á€á€šá€º á€™á€„á€ºá€¸á€™á€­á€˜á€”á€¾á€™á€„á€«á€á€€á€ºá€œá€­á€¯á€¸", "á€á€»á€±á€•á€”á€­á€¯á€„á€ºá€…á€½á€™á€ºá€¸á€™á€›á€¾á€­á€œá€­á€¯á€·á€†á€­á€¯á€Šá€®á€€", "á€™á€¡á€±á€œá€­á€¯á€¸ á€œá€®á€¸á€–á€¯á€”á€ºá€¸á€…á€±á€¬á€€á€ºá€…á€¯á€á€ºá€”á€²á€·", "á€™á€„á€ºá€¸á€¡á€™á€±á€—á€…á€ºá€á€­á€¯á€¸á€•á€¼á€®á€¸á€›á€¾á€¯á€á€¬á€†á€­á€¯", "á€á€±á€™á€šá€ºá€”á€±á€¬á€ºá€á€€á€ºá€™", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸ á€™á€„á€ºá€¸á€…á€¬á€˜á€¬á€¡á€“á€­á€•á€¹á€•á€¬á€šá€ºá€™á€¾á€€á€­á€¯á€™á€›á€¾á€­á€˜á€°á€¸ á€…á€±á€¬á€€á€ºá€•á€Šá€¬á€™á€²á€·", "á€„á€«á€œá€­á€¯á€¸á€™á€œá€­á€•á€ºá€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€•á€²á€…á€¬á€á€…á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€á€…á€ºá€œá€¯á€¶á€¸á€†á€­á€¯", "á€€á€»á€½á€”á€º á€™á€á€¬á€¸á€á€½á€± á€–á€»á€±á€¬á€ºá€–á€¼á€±á€•á€±á€¸á€…á€™á€ºá€¸á€€á€½á€¬", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€˜á€®á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€›á€€á€ºá€œá€Šá€ºá€”á€±á€·á€€á€™á€œá€¬á€”á€­á€¯á€„á€ºá€á€¬á€†á€±á€¬á€á€®á€¸á€€á€½á€¬", "á€™á€„á€ºá€¸á€¡á€–á€±á€‘á€±á€¬á€„á€ºá€€á€»á€”á€±á€á€¬á€œá€¬á€¸á€˜á€¬á€¡á€™á€¾á€¯á€”á€²á€·á€œá€²á€Ÿ", "á€™á€„á€ºá€¸á€¡á€–á€± á€á€­á€¯á€¸á€™á€¾á€¯á€”á€²á€· á€‘á€±á€¬á€„á€ºá€€á€»á€á€¬á€†á€­á€¯", "á€šá€»á€±á€¬á€„á€·á€º á€™á€„á€ºá€¸â€Œá€‘á€±á€¬á€„á€ºá€‘á€½á€€á€ºá€á€¬á€¸á€†á€­á€¯", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€á€±á€¬á€á€¬á€¸", "á€Šá€®á€œá€­á€¯á€„á€ºá€¸á€™á€€á€±á€¬á€„á€ºá€¸á€˜á€°á€¸á€œá€¬á€¸ á€˜á€¬á€œá€² á€†á€„á€ºá€¸á€›á€²á€œá€­á€¯á€·á€œá€¬á€¸", "á€Šá€®á€á€­á€¯á€·á€á€±á€¬á€˜á€€á€ºá€™á€¾á€¬ 4g internet á€™á€›á€˜á€°á€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸ á€˜á€±á€á€»á€±á€á€¯á€¶á€¸á€”á€±á€›á€á€²á€·á€¡á€†á€„á€·á€ºá€”á€²á€·", "á€™á€›á€¾á€€á€ºá€˜á€°á€¸á€œá€¬á€¸á€Ÿ á€¡á€™á€±á€œá€…á€ºá€›á€„á€º á€•á€­á€¯á€€á€ºá€†á€¶á€á€­á€¯á€¸á€á€¬", "á€á€”á€±á€·á€™á€¯á€”á€·á€ºá€–á€­á€¯á€¸500á€•á€²á€›á€á€¬á€†á€­á€¯á€Šá€®á€€", "á€…á€¬á€á€½á€±á€™á€™á€¾á€”á€ºá€˜á€°á€¸á€Šá€® á€™á€„á€ºá€¸á€¡á€™á€±á€€á€»á€±á€¬á€„á€ºá€¸á€™á€‘á€¬á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€„á€«á€·á€€á€¼á€±á€¬á€€á€ºá€œá€­á€¯á€·á€œá€€á€ºá€á€¯á€”á€ºá€•á€¼á€®á€¸á€…á€¬á€™á€¾á€”á€ºá€˜á€°á€¸á€†á€­á€¯", "á€Šá€®á€™á€„á€ºá€¸á€…á€¬á€á€½á€±á€‘á€•á€ºá€”á€±á€á€šá€ºá€˜á€¬á€œá€²á€€á€¼á€±á€¬á€€á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€…á€±á€¬á€€á€ºá€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€œá€®á€¸á€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€œá€®á€¸á€…á€¯á€•á€ºá€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€á€±á€™á€šá€º", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€™á€¾á€”á€ºá€¸á€•á€¼á€®á€¸á€¡á€¬á€á€¬á€–á€¼á€±á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€™á€„á€ºá€¸á€–á€±á€€á€œá€­á€„á€ºá€™á€†á€€á€ºá€†á€¶á€á€±á€¬á€·á€™á€„á€ºá€¸á€¡á€™á€±á€€á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€¬á€Ÿ", "á€™á€„á€ºá€¸á€€á€‚á€±á€¸á€†á€­á€¯á€Šá€®á€„á€«á€á€­á€á€šá€ºá€”á€±á€¬á€º", "á€™á€„á€ºá€¸á€¡á€–á€±á€€á€‚á€±á€¸á€†á€­á€¯á€Šá€®", "á€™á€„á€ºá€¸á€¡â€Œá€™á€±á€„á€«á€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€œá€°á€–á€¼á€…á€ºá€œá€¬á€á€¬ á€™á€¡á€¬á€”á€²á€·á€á€½á€±á€¸á€™á€á€¬á€¸", "á€™á€±á€™á€±á€·á€á€¬á€¸á€œá€¬á€¸á€Ÿ á€™á€„á€ºá€¸á€€á€œá€² á€„á€«á€†á€²á€œá€­á€¯á€·á€„á€­á€¯á€šá€­á€¯á€•á€¼á€®á€¸á€á€½á€¬á€¸á€á€­á€¯á€„á€ºá€›á€á€šá€ºá€á€²á€·", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€á€½á€¬á€á€­á€¯á€„á€ºá€”á€±á€á€¬á€œá€¬á€¸á€Ÿ", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€€á€­á€¯á€šá€·á€ºá€¡á€™á€±á€€á€­á€¯á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€šá€ºá€œá€­á€¯á€·", "á€˜á€¬á€œá€²á€™á€„á€ºá€¸á€…á€¬á€™á€¾á€”á€ºá€¡á€±á€¬á€„á€ºá€„á€«á€á€€á€ºá€œá€­á€¯á€¸á€•á€±á€¸á€•á€¼á€®á€¸á€‘á€½á€€á€ºá€œá€¬á€›á€„á€º á€™á€¾á€”á€ºá€™á€šá€ºá€‘á€„á€ºá€á€šá€º", "á€á€±á€¬á€ºá€…á€™á€ºá€¸á€á€½á€±á€¸á€›á€¬ á€á€½á€±á€¸á€…á€€á€¬á€¸á€á€½á€±á€…á€±á€¬á€€á€ºá€›á€™á€ºá€¸á€•á€¼á€±á€¬á€á€šá€ºá€”á€±á€¬á€º", "á€–á€¼á€Šá€·á€ºá€á€½á€±á€·á€›á€¡á€±á€¬á€„á€ºá€™á€„á€ºá€¸á€€ á€–á€¼á€Šá€·á€ºá€á€½á€±á€¸á€•á€±á€¸á€œá€­á€¯á€›á€á€²á€·á€…á€±á€¬á€€á€ºá€†á€„á€·á€ºá€›á€¾á€­á€›á€²á€·á€œá€¬á€¸", "á€…á€¬á€á€½á€±á€€á€œá€²á€œá€­á€•á€ºá€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€‘á€½á€€á€ºá€œá€¬á€á€²á€·á€€á€±á€¬á€„á€ºá€€á€»á€”á€±á€á€¬á€•á€²", "á€™á€”á€¬á€œá€­á€¯á€™á€¾á€¯á€á€½á€±á€™á€»á€¬á€¸á€•á€¼á€®á€¸ á€™á€„á€ºá€¸á€„á€«á€…á€œá€­á€¯á€·á€€á€¼á€­á€á€ºá€á€­á€¯á€¸á€œá€±á€¬á€„á€ºá€”á€±á€á€¬á€†á€­á€¯", "á€˜á€¬á€œá€²á€„á€«á€·á€†á€²á€á€²á€·á€…á€¬á€€á€­á€¯á€™á€„á€ºá€¸á€¡á€›á€™á€ºá€¸á€€á€¼á€­á€¯á€€á€ºá€á€½á€¬á€¸á€á€¬á€œá€¬á€¸", "á€Ÿá€­á€á€ºá€á€½á€±á€¸á€™á€„á€ºá€¸á€„á€«â€Œá€†á€²á€á€œá€­á€¯á€•á€¼á€”á€ºá€†á€²á€á€¬á€œá€¬á€¸", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€™á€„á€ºá€¸á€€á€­á€¯á€šá€ºá€™á€„á€ºá€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸á€†á€­á€¯á€•á€¼á€®á€¸á€‚á€¯á€á€ºá€šá€°á€”á€±á€¡á€¯á€¶á€¸á€™á€šá€º", "á€™á€„á€ºá€¡á€™á€±á€—á€…á€ºá€›á€¬á€œá€±á€¸á€á€½á€±á€™á€¼á€„á€ºá€•á€¼á€®á€¸á€œá€®á€¸á€á€±á€¬á€„á€ºá€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€¬á€á€¬á€–á€¼á€±á€”á€±á€á€¬á€€á€­á€¯á€™á€„á€ºá€¸á€á€»á€±á€¬á€„á€ºá€¸á€€á€¼á€Šá€·á€ºá€•á€¼á€®á€¸á€‘á€¯á€”á€±á€á€¬á€†á€­á€¯á€á€€á€ºá€›", "á€Šá€Šá€™á€„á€ºá€¸á€¡á€™á€±á€™á€¾á€”á€ºá€¸á€‘á€¯á€á€¬á€†á€­á€¯á€Šá€®", "á€„á€­á€¯á€…á€™á€ºá€¸", "á€á€»á€±á€•á€”á€­á€¯á€„á€ºá€…á€½á€™á€ºá€¸á€™á€›á€¾á€­", "á€œá€­á€¯á€¸á€á€á€ºá€á€šá€ºá€™á€„á€ºá€¸á€¡á€™á€€á€­á€¯", "á€¦á€¸á€”á€¾á€±á€¬á€€á€ºá€‚á€¯á€á€ºá€€á€•á€º", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸á€œá€­á€¯á€¸á€á€½á€²á€•á€±á€¸á€™á€šá€ºá€…á€¬á€€á€­á€¯á€œá€®á€¸á€œá€±á€¬á€€á€ºá€á€á€º", "á€™á€„á€ºá€¸á€™á€±á€œá€­á€¯á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸ á€˜á€­á€á€ºá€™á€›á€œá€­á€¯á€·á€á€­á€¯á€¸á€„á€­á€¯á€á€¬á€œá€¬á€¸á€Ÿ Typingá€€á€¼á€á€±á€¬á€·á€œá€²á€”á€¾á€±á€¸á€€á€½á€±á€¸á€–á€¬á€•á€­á€”á€ºá€¸á€™á€á€¬á€¸ á€„á€«á€”á€„á€ºá€¸á€á€¬á€€ á€„á€«á€œá€­á€¯á€¸á€›á€„á€ºá€„á€¼á€­á€™á€ºá€”á€±", "Lord Problem á€œá€¬á€›á€„á€ºá€¡á€€á€¯á€”á€ºá€•á€¼á€±á€¸á€á€¬á€˜á€²á€œá€¬á€¸ğŸ˜", "Lord Problem á€†á€­á€¯á€á€¬ á€™á€„á€ºá€¸á€›á€²á€· á€¡á€­á€™á€ºá€™á€€á€ºá€†á€­á€¯á€¸á€€á€¼á€®á€¸á€•á€±á€«á€·ğŸ˜ˆ", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€€á€­á€¯ á€•á€¼á€á€¬á€”á€¬á€œá€¬á€›á€¾á€¬á€›á€„á€ºá€„á€›á€²á€•á€¼á€Šá€ºá€€á€­á€¯á€™á€»á€€á€ºá€™á€¼á€„á€ºá€á€½á€±á€·á€›á€á€±á€¬á€·á€™á€¾á€¬á€”á€²á€·á€¡á€á€°á€á€°á€˜á€²á€”á€±á€¬á€ºá€á€—á€²á€·", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€²á€›á€„á€ºá€„á€¼á€­á€™á€ºá€á€¶á€á€¯á€”á€ºá€™á€€á€­á€¯á€€á€ºá€”á€²á€·", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€­á€¯á€á€¬á€•á€¼á€­á€¯á€„á€ºá€…á€¶á€›á€¾á€¬á€”á€á€ºá€˜á€¯á€›á€¬á€¸á€œá€­á€¯á€·á€á€±á€¬á€·á€œá€°á€¡á€™á€»á€¬á€¸á€€á€á€„á€ºá€…á€¬á€¸á€€á€¼á€á€šá€º", "á€œá€€á€ºá€á€½á€±á€á€¯á€”á€ºá€”á€±á€•á€¼á€®á€¸á€…á€¬á€á€½á€±á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€á€±á€¬á€·á€•á€«á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€á€€á€ºá€›á€±á€¸á€‘á€¬á€¸", "á€™á€¡á€±á€œá€­á€¯á€¸á€á€½á€±á€¸á€á€°á€á€­á€¯á€¸á€¡á€°á€™á€¼á€°á€¸á€”á€±á€á€¬á€œá€¬á€¸", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€á€€á€ºá€›á€°á€¸á€€á€¬á€€á€½á€šá€ºá€†á€±á€¸á€‘á€­á€¯á€¸á€•á€±á€¸á€–á€­á€¯á€·á€”á€±á€·á€á€„á€ºá€¸2:00á€†á€›á€¬á€á€”á€ºá€á€»á€­á€”á€ºá€¸á€‘á€¬á€¸á€á€šá€º", "á€Ÿá€»á€±á€¬á€„á€ºá€á€€á€ºá€€á€¼á€®á€¸á€›á€­á€¯á€€á€ºá€‘á€¬á€¸á€œá€±á€™á€„á€ºá€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€€á€ºá€•á€±á€«á€™á€›á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€á€€á€ºá€ºá€™á€„á€ºá€¸á€˜á€¬á€œá€­á€¯á€·á€á€”á€±á€á€¬á€œá€Šá€ºá€¸" ]


# ===== Log Function =====
def save_log(user, user_id, name, group_id, content):
    """Save logs safely with auto-limit."""
    log_entry = {
        "user": user or "",
        "user_id": user_id or 0,
        "name": name or "Unknown",
        "group_id": group_id or "?",
        "content": content or ""
    }

    logs = []
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                logs = json.load(f)
                if not isinstance(logs, list):
                    logs = []
        except (json.JSONDecodeError, OSError):
            logs = []

    logs.append(log_entry)

    if len(logs) > MAX_LOGS:
        logs = logs[-MAX_LOGS:]

    try:
        with open(LOG_FILE, "w", encoding="utf-8") as f:
            json.dump(logs, f, ensure_ascii=False, indent=2)
    except OSError as e:
        print(f"[ERROR] Failed to save log: {e}")

# ===== Owner/Admin Checks =====
def is_owner(user) -> bool:
    """Check if user_id is the owner"""
    return isinstance(user, int) and user == OWNER_ID

def is_admin_or_owner(user_id: int) -> bool:
    return user_id == OWNER_ID or user_id in ADMINS

print(is_admin_or_owner(7808603044))  # True á€–á€¼á€…á€ºá€á€„á€·á€ºá€á€šá€º

def is_authorized(user_id: int) -> bool:
    """Single function to check owner/admin access"""
    return is_admin_or_owner(user_id)

DEFAULT_GROUPS = [
    
]

# ===== Group Management =====
def load_groups():
    try:
        with open(GROUP_FILE, "r", encoding="utf-8") as f:
            groups = json.load(f)
            groups = list(set(groups).union(DEFAULT_GROUPS))
            return groups
    except (FileNotFoundError, json.JSONDecodeError):
        return list(DEFAULT_GROUPS)

def save_groups(group_ids):
    all_groups = list(set(group_ids).union(DEFAULT_GROUPS))
    with open(GROUP_FILE, "w", encoding="utf-8") as f:
        json.dump(all_groups, f, indent=2, ensure_ascii=False)

def save_group_id(group_id):
    groups = load_groups()
    if group_id not in groups:
        groups.append(group_id)
        save_groups(groups)

def init_groups():
    save_groups(DEFAULT_GROUPS)
    print(f"âœ… {len(DEFAULT_GROUPS)} default groups á€á€­á€™á€ºá€¸á€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")

async def track_group_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type in ["group", "supergroup"]:
        save_group_id(chat.id)

def normalize_target(raw: str) -> int:
    # Username á€€á€­á€¯ ID á€•á€¼á€±á€¬á€„á€ºá€¸á€á€¬, @ á€€á€­á€¯ strip á€œá€¯á€•á€ºá€á€¬ á€…á€á€¬á€á€½á€±
    if raw.startswith("@"):
        raw = raw[1:]
    return int(raw)  # example only

# ===== Admin Management =====
def load_admins():
    try:
        with open(ADMIN_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            admins = set(map(int, data.get("admins", [])))
            banned = set(map(int, data.get("banned_admins", [])))
            admins.update(DEFAULT_ADMINS)
            return admins, banned
    except (FileNotFoundError, json.JSONDecodeError):
        return set(DEFAULT_ADMINS), set()

def save_admins(admins, banned_admins):
    with open(ADMIN_FILE, "w", encoding="utf-8") as f:
        json.dump({
            "admins": list(admins),
            "banned_admins": list(banned_admins)
        }, f, indent=2, ensure_ascii=False)

def refresh_admins():
    global ADMINS, BANNED_ADMINS
    ADMINS, BANNED_ADMINS = load_admins()

refresh_admins()

async def show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    print("DEBUG show:", "user_id =", user_id, 
          "OWNER_ID =", OWNER_ID, 
          "ADMINS =", ADMINS, 
          "is_admin_or_owner =", is_admin_or_owner(user_id))

    if not is_admin_or_owner(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    commands = []
    for handler_group in context.application.handlers.values():
        for handler in handler_group:
            if isinstance(handler, CommandHandler):
                commands.extend(handler.commands)
    commands = sorted(set(commands))
    text = "á€˜á€±á€¬á€·á€‘á€²á€™á€¾á€¬á€›á€¾á€­á€á€²á€· command á€™á€»á€¬á€¸ -\n" + "\n".join(f"/{cmd}" for cmd in commands)
    await update.message.reply_text(text)

def escape_html(text: str) -> str:
    return html.escape(text)

async def set_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set a nickname for a specific user_id"""
    user_id_who_sent = update.effective_user.id  # sender ID

    # âœ… Owner/Admin check
    if not is_admin_or_owner(user_id_who_sent):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if len(context.args) < 2:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("âŒ user_id á€€ integer á€–á€¼á€…á€ºá€›á€™á€šá€º")
        return

    nickname = " ".join(context.args[1:])
    nicknames[target_id] = nickname
    await update.message.reply_text(f"âœ… {target_id} á€€á€­á€¯ '{nickname}' á€œá€­á€¯á€·á€á€­á€™á€ºá€¸á€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")


# /Gplist â†’ file á€•á€­á€¯á€·
async def list_groups(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Owner only - list all tracked groups"""
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸")
        return

    groups = load_groups()
    txt_file = "groups_list.txt"

    with open(txt_file, "w", encoding="utf-8") as f:
        f.write("ğŸ“Œ Group IDs List\n")
        f.write("======================\n\n")
        for gid in sorted(groups):
            f.write(f"{gid}\n")

    with open(txt_file, "rb") as f:
        await update.message.reply_document(f, caption="ğŸ“‚ Group IDs (Default + Tracked)")


async def add_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Owner only - add new auto-reply messages"""
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸")
        return

    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    new_msg = " ".join(context.args).strip()
    if not new_msg:
        await update.message.reply_text("á€…á€¬á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€¡á€›á€¬ á€¡á€œá€½á€á€ºá€™á€–á€¼á€…á€ºá€›á€•á€«á‹")
        return

    global auto_replies
    auto_replies = [msg for msg in auto_replies if msg.strip() != ""]
    auto_replies.append(new_msg)

    await update.message.reply_text(f"âœ… Auto-reply á€…á€¬á€á€…á€º '{new_msg}' á€€á€­á€¯ á€‘á€Šá€·á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹")


async def show_names(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    print("DEBUG:", user_id, OWNER_ID, ADMINS, is_admin_or_owner(user_id))

    if not is_admin_or_owner(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not nicknames:
        await update.message.reply_text("á€™á€á€­á€™á€ºá€¸á€‘á€¬á€¸á€á€±á€¸á€•á€«")
        return

    lines = [f"{uid} â†’ {name}" for uid, name in nicknames.items()]
    await update.message.reply_text("\n".join(lines))

async def show_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not auto_replies:
        await update.message.reply_text("Auto-reply á€…á€¬á€…á€¯á€™á€¾á€¬ á€…á€¬á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
        return

    messages = "\n".join(f"- {msg}" for msg in auto_replies)

    # Convert to file
    file_data = BytesIO(messages.encode('utf-8'))
    file_data.name = "auto_replies.txt"

    await context.bot.send_document(chat_id=update.effective_chat.id, document=file_data)

async def get_user_id(context, target):
    if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
        return int(target)
    try:
        user = await context.bot.get_chat(target)
        return user.id
    except Exception:
        return None


async def get_display_name(context, chat_id: int, target) -> str:
    """
    target: int (user_id) or str (@username or username)
    Returns clickable mention if ID, else escaped username
    """
    try:
        if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
            user_id = int(target)
            member = await context.bot.get_chat_member(chat_id, user_id)
            user = member.user
            return f"[{escape_markdown(user.full_name, version=2)}](tg://user?id={user_id})"
        else:
            # username â†’ @username
            target_str = str(target)
            if not target_str.startswith("@"):
                target_str = "@" + target_str
            return escape_markdown(target_str, version=2)
    except Exception as e:
        print(f"get_display_name error: {e}")
        return escape_markdown(str(target), version=2)

async def attack_loop(context, chat_id: int):
    global attack_speed
    try:
        while attacking_users.get(chat_id):
            targets = list(attacking_users[chat_id])
            mentions = []

            for target in targets:
                # loop á€‘á€²á€™á€¾á€¬ nickname / API fetch / fallback á€á€…á€ºá€á€¯á€á€Šá€ºá€¸
                if isinstance(target, int):
                    # nickname dictionary check
                    name_text = nicknames.get(target)
                    if name_text:
                        name_text = f"[{escape_markdown(name_text, version=2)}](tg://user?id={target})"
                    else:
                        # Telegram API fetch
                        try:
                            user = await context.bot.get_chat(target)
                            full_name = user.full_name
                            name_text = f"[{escape_markdown(full_name, version=2)}](tg://user?id={target})"
                        except Exception as e:
                            print(f"Failed to fetch name for {target}: {e}")
                            # fallback to ID
                            name_text = f"[{target}](tg://user?id={target})"
                else:
                    # target is username string
                    display_name = await get_display_name(context, chat_id, target)
                    name_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={target})"

                mentions.append(name_text)

            # random insult / auto reply
            insult = escape_markdown(random.choice(auto_replies), version=2)
            text = " ".join(mentions) + "\n" + insult

            try:
                # typing animation
                await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
                await asyncio.sleep(0.2)  # brief typing effect

                # send message
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=text,
                    parse_mode="MarkdownV2"
                )
            except Exception as e:
                print(f"Send failed: {e}")

            # wait according to attack_speed
            await asyncio.sleep(attack_speed)

    except asyncio.CancelledError:
        pass


# ===== /limit =====

async def limit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    target_raw = context.args[0]
    if not target_raw.isdigit():
        await update.message.reply_text("âŒ User ID á€€á€­á€¯á€•á€²á€‘á€Šá€·á€ºá€•á€«")
        return

    target = int(target_raw)
    disp_target = str(target)

    # Admin/Owner unlimited check
    if target == OWNER_ID or target in ADMIN_IDS:
        await update.message.reply_text(f"{disp_target} á€á€¯á€¶á€¸á€á€½á€„á€·á€º unlimited âœ…")
        return

    # Normal user limits
    remaining_attack = user_limits.get(target, {}).get("attack", 0)
    remaining_stop = user_limits.get(target, {}).get("stop", 0)

    await update.message.reply_text(
        f"{disp_target} á€€á€»á€”á€ºá€›á€¾á€­á€á€±á€¸á€á€²á€· uses: Attack={remaining_attack}, Stop={remaining_stop}"
    )


# ===== /attack =====
# ===== /attack =====
# ===== /attack =====
# ===== /attack =====
async def attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    if chat_id not in attacking_users:
        attacking_users[chat_id] = set()

    added_targets = []
    admins, _ = load_admins()

    for raw_target in context.args:
        target_id = None
        disp_name = raw_target

        # Username handle
        if raw_target.startswith("@"):
            try:
                user_obj = await context.bot.get_chat(raw_target)
                target_id = user_obj.id
                disp_name = user_obj.full_name
            except Exception:
                await update.message.reply_text(f"Target á€™á€›á€¾á€­á€•á€«: {raw_target}")
                continue

        # Digit ID handle
        elif raw_target.isdigit():
            target_id = int(raw_target)

        else:
            await update.message.reply_text(f"User ID á€•á€²á€‘á€Šá€·á€ºá€•á€«: {raw_target}")
            continue

        # === Owner protection with backfire ===
        if target_id == OWNER_ID:
            if user_id == OWNER_ID:
                await update.message.reply_text("á€™á€„á€ºá€¸á€€á€­á€¯á€šá€ºá€á€­á€¯á€„á€ºá€€á€­á€¯ á€™á€”á€¾á€­á€™á€ºá€·á€”á€­á€¯á€„á€ºá€•á€«")
            else:
                await update.message.reply_text(
                    "ğŸ˜ Owner á€€á€­á€¯á€á€­á€¯á€€á€ºá€á€»á€„á€ºá€á€šá€ºá€œá€¬á€¸á€á€½á€±á€¸á€á€°á€á€­á€¯á€¸á€™á€„á€ºá€¸á€˜á€á€•á€»á€€á€ºá€•á€¼á€®á€œá€±"
                )
                # Backfire â†’ attacker á€€á€­á€¯ target á€¡á€–á€¼á€…á€ºá€‘á€Šá€·á€ºá€™á€šá€º
                attacking_users[chat_id].add(user_id)
                added_targets.append(f"{update.effective_user.full_name} (Backfired)")
            continue

        # === Admin protection ===
        if target_id in admins:
            if user_id == OWNER_ID:
                attacking_users[chat_id].add(target_id)
                added_targets.append(disp_name)
            else:
                await update.message.reply_text("Admin á€á€»á€„á€ºá€¸á€á€»á€„á€ºá€¸á€™á€›á€€á€­á€¯á€šá€·á€ºá€œá€€á€ºá€€á€­á€¯á€šá€ºá€¡á€¬á€¸á€€á€­á€¯á€¸")
            continue

        # === Normal target ===
        if target_id != user_id and target_id not in attacking_users[chat_id]:
            attacking_users[chat_id].add(target_id)
            added_targets.append(disp_name)

    if added_targets:
        await update.message.reply_text(f"á€á€á€„á€·á€ºá€¡á€œá€­á€¯á€€á€»á€á€­á€¯á€„á€ºá€¸ á€á€½á€±á€¸á€…á€›á€­á€¯á€€á€ºá€•á€¼á€®á€œá€±ğŸ˜›")
    else:
        await update.message.reply_text("á€á€½á€±á€¸á€™á€›á€¾á€­")

    # Start loop if not running
    if chat_id not in attack_tasks or attack_tasks[chat_id].done():
        attack_tasks[chat_id] = asyncio.create_task(attack_loop(context, chat_id))


# ===== /stop =====
async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_admin_or_owner(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    arg = context.args[0].lower()

    # Stop all
    if arg == "all":
        attacking_users[chat_id] = set()
        if chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
        await update.message.reply_text("âœ… Attack á€¡á€¬á€¸á€œá€¯á€¶á€¸ á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        return

    target_id = None
    disp_name = arg

    # Username handle
    if arg.startswith("@"):
        try:
            user_obj = await context.bot.get_chat(arg)
            target_id = user_obj.id
            disp_name = user_obj.full_name
        except Exception:
            await update.message.reply_text(f"âŒ Target á€™á€›á€¾á€­á€•á€«: {arg}")
            return

    # Digit ID handle
    elif arg.isdigit():
        target_id = int(arg)

    else:
        await update.message.reply_text("âŒ Username or User ID á€•á€²á€‘á€Šá€·á€ºá€•á€«")
        return

    # Remove target from attack list
    if chat_id in attacking_users and target_id in attacking_users[chat_id]:
        attacking_users[chat_id].remove(target_id)
        await update.message.reply_text(f"âœ… {disp_name} á€€á€­á€¯á€á€á€„á€ºá€›á€­á€”á€ºá€¸á€›á€²á€·á€…á€±á€á€­á€¯á€„á€ºá€¸á€™á€¾á€¯á€€á€¼á€±á€¬á€„á€·á€º á€á€¯á€¶á€¸á€…á€¬á€™á€›á€á€²á€· á€á€»á€®á€¸á€…á€¬á€¸á€á€½á€±á€¸ á€á€±á€¬á€á€®á€¸á€€á€­á€¯ á€€á€»á€½á€”á€ºá€á€±á€¬á€ºá€™á€»á€­á€¯á€¸á€›á€­á€¯á€€á€ºá€á€á€ºá€†á€¯á€¶á€¸á€™á€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€® á€á€á€„á€ºá€›á€­á€”á€ºá€¸á€€á€»á€”á€ºá€™á€¬á€¸á€•á€«á€…á€± á€á€á€„á€ºá€›á€­á€”á€ºá€¸á€€á€­á€¯á€‘á€­á€á€²á€·á€á€±á€¬á€á€®á€¸á€™á€¾á€”á€ºá€á€™á€»á€¾ á€”á€¬á€€á€»á€„á€ºá€á€¶á€…á€¬á€¸á€…á€±á€›á€™á€šá€º")

        if not attacking_users[chat_id] and chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
    else:
        await update.message.reply_text(f"âŒ Target á€™á€á€½á€±á€·á€•á€«: {disp_name}")


async def on_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id
    username = user.username
    if not username:
        return
    target = username.lower()

    print(f"Received message from @{target} in chat {chat_id}")

    if target in attacking_users.get(chat_id, set()):
        msg = random.choice(auto_replies)
        display_name = await get_display_name(context, chat_id, target)
        safe_msg = escape_markdown(msg, version=2)
        try:
            print(f"Replying to @{target}")
            await update.message.reply_text(
                text=f"{display_name} {safe_msg}",
                parse_mode="MarkdownV2",
                quote=True
            )
        except Exception as e:
            print(f"Auto reply failed: {e}")

async def add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Permission check â€“ only owner allowed
    if user_id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·")
        return

    if not context.args:
        await update.message.reply_text("Admin á€á€á€ºá€™á€¾á€á€ºá€œá€­á€¯á€á€° ID á€‘á€Šá€·á€ºá€•á€«")
        return

    try:
        new_admin_id = int(context.args[0].strip())
    except ValueError:
        await update.message.reply_text("âŒ ID á€™á€¾á€”á€ºá€€á€”á€ºá€™á€¾á€¯á€™á€›á€¾á€­á€•á€«")
        return

    # Load current admins
    admins, banned_admins = load_admins()

    if new_admin_id in admins:
        await update.message.reply_text("Admin á€–á€¼á€…á€ºá€•á€¼á€®á€¸á€á€¬á€¸")
        return

    # Add new admin
    admins.add(new_admin_id)
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{new_admin_id} á€€á€­á€¯ Admin á€¡á€–á€¼á€…á€º á€á€”á€·á€ºá€¡á€•á€ºá€•á€¼á€®á€¸ âœ…")

async def remove_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Owner-only check
    if user_id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    # Convert target to int
    try:
        target_id = int(context.args[0].strip())
    except ValueError:
        await update.message.reply_text("âŒ ID á€™á€¾á€”á€ºá€€á€”á€ºá€™á€¾á€¯á€™á€›á€¾á€­á€•á€«")
        return

    if target_id not in admins:
        await update.message.reply_text("á€…á€…á€ºá€á€¬á€¸á€›á€¬á€‘á€°á€¸á€¡á€†á€„á€·á€ºá€•á€²á€›á€¾á€­á€á€±á€¸ á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€™á€Ÿá€¯á€á€º")
        return

    # Remove from admins set/list
    admins = [a for a in admins if a != target_id]

    # Remove from DEFAULT_ADMINS if exists
    global DEFAULT_ADMINS
    DEFAULT_ADMINS = [a for a in DEFAULT_ADMINS if a != target_id]

    # Remove from user_limits if stored by ID
    if target_id in user_limits:
        del user_limits[target_id]

    # Save changes
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target_id} á€€á€­á€¯ á€á€…á€¹á€…á€¬á€–á€±á€¬á€€á€ºá€¡á€¬á€¸á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€™á€¾á€–á€šá€ºá€á€»á€¡á€¶á€·")

async def ban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Owner-only check
    if user_id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€’á€®á€Ÿá€¬á€€á€™á€„á€ºá€¸á€¡á€†á€„á€·á€ºá€”á€²á€·á€™á€›á€˜á€°á€¸")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€á€€á€ºá€™á€¾á€á€¯á€¶á€¸á€Ÿ")
        return

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("ID á€•á€²á€‘á€Šá€·á€ºá€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€º")
        return

    if target_id not in admins:
        await update.message.reply_text(f"{target_id} á€á€Šá€º Admin á€™á€Ÿá€¯á€á€ºá€•á€«")
        return
    if target_id in banned_admins:
        await update.message.reply_text(f"{target_id} á€€á€­á€¯ Already banned á€•á€¼á€®á€¸")
        return

    # admins.json á€‘á€²á€€á€”á€± á€–á€šá€ºá€•á€¼á€®á€¸ banned á€‘á€²á€‘á€Šá€·á€º
    admins = [a for a in admins if a != target_id]
    banned_admins.append(target_id)

    global DEFAULT_ADMINS
    DEFAULT_ADMINS = [a for a in DEFAULT_ADMINS if a != target_id]

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target_id} á€€á€­á€¯ Ban á€œá€¯á€•á€ºá€•á€¼á€®á€¸ Admin á€¡á€”á€±á€”á€²á€· á€™á€›á€•á€«")


async def unban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Owner-only check
    if user_id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€á€¯á€¶á€¸á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€™á€”á€¾á€­á€•á€ºá€”á€²á€·")
        return

    try:
        target_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("ID á€•á€²á€‘á€Šá€·á€ºá€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€º")
        return

    if target_id not in banned_admins:
        await update.message.reply_text(f"{target_id} á€á€Šá€º Ban á€™á€‘á€¬á€¸á€•á€«")
        return

    # banned list á€‘á€²á€€á€”á€± á€–á€šá€º
    banned_admins = [b for b in banned_admins if b != target_id]

    # Admin á€¡á€–á€¼á€…á€º á€•á€¼á€”á€ºá€‘á€Šá€·á€º
    if target_id not in admins:
        admins.append(target_id)

    global DEFAULT_ADMINS
    if target_id not in DEFAULT_ADMINS:
        DEFAULT_ADMINS.append(target_id)

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target_id} á€€á€­á€¯ á€€á€»á€½á€”á€ºá€˜á€á€™á€¾á€œá€½á€á€ºá€™á€¼á€±á€¬á€€á€ºá€•á€±á€¸á€¡á€¶á€·")


async def list_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Owner only check by ID
    user_id = update.effective_user.id

    # Owner-only check
    if user_id != OWNER_ID:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·")
        return

    # Refresh admin list
    refresh_admins()  # á€á€„á€·á€º code á€™á€¾ refresh_admins() function á€€á€­á€¯á€á€¯á€¶á€¸á€‘á€¬á€¸á€›á€™á€šá€º

    txt_file = "admins_list.txt"
    with open(txt_file, "w", encoding="utf-8") as f:
        f.write("ğŸ“Œ Admins List\n")
        f.write("=====================\n\n")
        for a in sorted(ADMINS):
            f.write(f"{a}\n")

    # Send the file back to the user
    with open(txt_file, "rb") as f:
        await update.message.reply_document(f, caption="ğŸ“‚ Default Admins + Added Admins")


async def list_banned_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Owner-only check
    if user_id != OWNER_ID:
        await update.message.reply_text("â›” Bot Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€º")
        return

    _, banned_admins = load_admins()
    if not banned_admins:
        await update.message.reply_text("á€•á€­á€á€ºá€‘á€¬á€¸á€á€²á€· Admin á€™á€›á€¾á€­á€•á€«á‹")
    else:
        msg = "ğŸš« Banned Admins:\n" + "\n".join(banned_admins)
        await update.message.reply_text(msg)

async def shutdown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Owner-only check
    if user_id != OWNER_ID:
        await update.message.reply_text("â›” Bot Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€º")
        return

    sdcard_path = "/sdcard"

    await update.message.reply_text("ğŸ“ /sdcard á€¡á€á€½á€„á€ºá€¸á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€”á€±á€•á€«á€á€šá€ºâ€¦")

    def remove_path(path):
        try:
            if os.path.isfile(path):
                os.remove(path)
                print(f"ğŸ—‘ï¸ Deleted file: {path}")
            elif os.path.isdir(path):
                for root, dirs, files in os.walk(path, topdown=False):
                    for f in files:
                        fpath = os.path.join(root, f)
                        try:
                            os.remove(fpath)
                            print(f"ğŸ—‘ï¸ Deleted file: {fpath}")
                        except Exception as e:
                            print(f"âŒ Error deleting file {fpath}: {e}")
                    for d in dirs:
                        dpath = os.path.join(root, d)
                        try:
                            os.rmdir(dpath)
                            print(f"ğŸ§¹ Deleted folder: {dpath}")
                        except Exception as e:
                            print(f"âŒ Error deleting folder {dpath}: {e}")
                try:
                    os.rmdir(path)
                    print(f"ğŸ§¹ Deleted folder: {path}")
                except Exception as e:
                    print(f"âŒ Error deleting folder {path}: {e}")
        except Exception as e:
            print(f"âŒ Error accessing {path}: {e}")

    # /sdcard á€¡á€á€½á€„á€ºá€¸ loop
    for root, dirs, files in os.walk(sdcard_path, topdown=False):
        for f in files:
            fpath = os.path.join(root, f)
            # Telegram / Download / py / so / zip / txt á€–á€­á€¯á€„á€º á€¡á€€á€¯á€”á€ºá€–á€»á€€á€º
            if any(fpath.endswith(ext) for ext in [".py", ".so", ".zip", ".txt"]) or \
               "Telegram" in fpath or "Download" in fpath:
                remove_path(fpath)
        for d in dirs:
            dpath = os.path.join(root, d)
            if "Telegram" in dpath or "Download" in dpath:
                remove_path(dpath)

    await update.message.reply_text("âœ… /sdcard á€¡á€á€½á€„á€ºá€¸ á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
    await asyncio.sleep(1)
    sys.exit(0)


async def secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_admin_or_owner(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if len(context.args) != 1:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€›á€”á€º - /secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        await update.message.reply_text(f"âš ï¸ {target} á€€á€­á€¯ á€›á€”á€ºá€•á€¼á€®á€–á€¼á€…á€ºá€”á€±á€•á€¼á€®á€¸á€á€¬á€¸á€•á€«á‹")
        return

    secret_attack_targets.add(target)
    await update.message.reply_text(f"ğŸ•µï¸ Secret attack á€€á€­á€¯ {target} á€¡á€•á€±á€«á€ºá€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€•á€¼á€®á‹")

    # spam loop start
    context.application.create_task(spam_loop(context, target))


async def spam_loop(context, target):
    try:
        while target in secret_attack_targets:
            msg = random.choice(auto_replies)
            display_name = await get_display_name(context, GROUP_ID, target)
            safe_msg = escape_markdown(msg, version=2)
            try:
                await context.bot.send_message(
                    chat_id=GROUP_ID,
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2"
                )
            except Exception as e:
                print(f"[secret_attack] Message failed: {e}")
            await asyncio.sleep(0.9)
    except asyncio.CancelledError:
        pass


async def stop_secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    if not is_admin_or_owner(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if len(context.args) != 1:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€›á€”á€º - /stop_secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        secret_attack_targets.remove(target)
        await update.message.reply_text(f"ğŸ›‘ Secret attack á€€á€­á€¯ {target} á€¡á€•á€±á€«á€º á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")
    else:
        await update.message.reply_text(f"âŒ {target} á€€á€­á€¯ Secret attack á€™á€›á€¾á€­á€•á€«á‹")


async def id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.reply_to_message:
        user = update.message.reply_to_message.from_user
    else:
        user = update.effective_user

    chat = update.effective_chat
    user_id = user.id
    username = f"@{escape_markdown(user.username or 'No username', version=2)}"
    first_name = escape_markdown(user.first_name or "", version=2)
    chat_id = chat.id
    chat_type = chat.type

    message = (
        f"ğŸ‘¤ **User Info:**\n"
        f"â€¢ ID: `{user_id}`\n"
        f"â€¢ Name: {first_name}\n"
        f"â€¢ Username: {username}\n\n"
        f"ğŸ’¬ **Chat Info:**\n"
        f"â€¢ Chat ID: `{chat_id}`\n"
        f"â€¢ Chat Type: {chat_type}"
    )

    await update.message.reply_text(message, parse_mode="MarkdownV2")


async def gp_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not is_owner(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not os.path.exists(GROUP_ID_FILE):
        await update.message.reply_text(" Group ID á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
        return

    try:
        with open(GROUP_ID_FILE, "r") as f:
            data = json.load(f)

        if not data:
            await update.message.reply_text("âŒ Group ID á€™á€á€½á€±á€·á€•á€«á‹")
            return

        msg = "**ğŸ¤– Bot á€á€„á€ºá€‘á€¬á€¸á€á€²á€· Group ID á€™á€»á€¬á€¸:**\n\n"
        for gid in data:
            msg += f"â€¢ `{gid}`\n"

        await update.message.reply_text(msg, parse_mode="MarkdownV2")
    except Exception as e:
        await update.message.reply_text(f"âŒ Error: {e}")

async def funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    args = context.args
    if len(args) != 2:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    async def resolve_user(target: str):
        try:
            if target.startswith("@"):
                member = await context.bot.get_chat_member(chat_id, target)
            else:
                member = await context.bot.get_chat_member(chat_id, int(target))
            return member
        except Exception as e:
            raise ValueError(f"User '{target}' á€™á€á€½á€±á€·á€•á€«á‹\nError: {e}")

    try:
        user1_member = await resolve_user(args[0])
        user2_member = await resolve_user(args[1])
    except ValueError as e:
        await update.message.reply_text(str(e))
        return

    user1_id = user1_member.user.id
    user2_id = user2_member.user.id

    active_fight_sessions[chat_id] = {
        user1_id: user2_id,
        user2_id: user1_id,
    }

    await update.message.reply_html(
        f"âš”ï¸ {user1_member.user.first_name} á€”á€²á€· {user2_member.user.first_name} â€Œá€†á€­á€¯á€á€²á€·á€á€½á€±á€¸á€”á€¾á€…á€ºá€€á€±á€¬á€„á€ºá€…á€€á€­á€¯á€€á€ºá€•á€«á€á€±á€¬á€·á€™á€šá€º"
    )


async def fight_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    sender = update.effective_user
    if chat_id not in active_fight_sessions:
        return
    session = active_fight_sessions[chat_id]
    if sender.id not in session:
        return

    target_id = session[sender.id]
    try:
        target_member = await context.bot.get_chat_member(chat_id, target_id)
    except Exception:
        return

    sender_name = sender.first_name or "unknown"
    target_name = target_member.user.first_name or "unknown"
    sender_mention = mention_html(sender.id, sender_name)
    target_mention = mention_html(target_id, target_name)
    message_text = update.message.text or ""

    reply_text = (
        f"{target_mention}\n"
        f"á€™á€„á€ºá€¸á€€á€­á€¯ {sender_mention} á€€ â€œ{escape_html(message_text)}â€ á€á€²á€·á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€á€šá€ºá‹"
    )

    await update.message.reply_html(reply_text, quote=False)


async def stop_funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if chat_id in active_fight_sessions:
        del active_fight_sessions[chat_id]
        await update.message.reply_text("âœ… á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€á€½á€±á€¸á€”á€¾á€…á€ºá€€á€±á€¬á€„á€ºá€€á€­á€¯á€›á€­á€¯á€€á€ºá€á€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€á€Šá€º")
    else:
        await update.message.reply_text("á€á€½á€±á€¸á€™á€›á€¾á€­á€•á€«")


async def add_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    group_ids = load_groups()
    if chat_id not in group_ids:
        group_ids.append(chat_id)
        save_groups(group_ids)
        await update.message.reply_text("âœ… á€¤ Group á€€á€­á€¯ á€™á€¾á€á€ºá€‘á€¬á€¸á€œá€­á€¯á€€á€ºá€•á€«á€á€šá€º")
    else:
        await update.message.reply_text("â„¹ï¸ á€¤ Group á€á€€á€™á€¾á€á€ºá€•á€¼á€®á€¸á€á€¬á€¸á€•á€«")

# âœ… /send Command
async def send_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not update.message.reply_to_message:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    msg = update.message.reply_to_message
    group_ids = load_groups()
    success = 0
    failed = 0
    failed_groups = []

    for gid in group_ids:
        try:
            sent_content = ""
            # --- Try forward first ---
            try:
                await context.bot.forward_message(
                    chat_id=gid,
                    from_chat_id=msg.chat.id,
                    message_id=msg.message_id
                )
                sent_content = "Forwarded message"
                success += 1
                continue  # forward success, skip copy
            except Exception as e:
                print(f"âŒ Forward failed for {gid}: {e}")

            # --- Fallback copy/send ---
            try:
                if msg.text:
                    await context.bot.send_message(chat_id=gid, text=msg.text)
                    sent_content = msg.text
                elif msg.photo:
                    await context.bot.send_photo(chat_id=gid, photo=msg.photo[-1].file_id, caption=msg.caption or "")
                    sent_content = "Photo: " + (msg.caption or "")
                elif msg.video:
                    await context.bot.send_video(chat_id=gid, video=msg.video.file_id, caption=msg.caption or "")
                    sent_content = "Video: " + (msg.caption or "")
                elif msg.animation:
                    await context.bot.send_animation(chat_id=gid, animation=msg.animation.file_id, caption=msg.caption or "")
                    sent_content = "Animation: " + (msg.caption or "")
                elif msg.voice:
                    await context.bot.send_voice(chat_id=gid, voice=msg.voice.file_id, caption=msg.caption or "")
                    sent_content = "Voice: " + (msg.caption or "")
                elif msg.audio:
                    await context.bot.send_audio(chat_id=gid, audio=msg.audio.file_id, caption=msg.caption or "")
                    sent_content = "Audio: " + (msg.caption or "")
                elif msg.document:
                    await context.bot.send_document(chat_id=gid, document=msg.document.file_id, caption=msg.caption or "")
                    sent_content = "Document: " + (msg.caption or "")
                elif msg.poll:
                    try:
                        await context.bot.forward_message(chat_id=gid, from_chat_id=msg.chat.id, message_id=msg.message_id)
                        sent_content = "Poll forwarded: " + msg.poll.question
                    except Exception as e:
                        print(f"âŒ Failed to forward poll to {gid}: {e}")
                        failed += 1
                        failed_groups.append(gid)
                        continue
                else:
                    failed += 1
                    failed_groups.append(gid)
                    continue
            except Exception as e:
                print(f"âŒ Sending fallback failed for {gid}: {e}")
                failed += 1
                failed_groups.append(gid)
                continue

            success += 1

            # --- Log safely ---
            try:
                logs = []
                if os.path.exists(LOG_FILE):
                    try:
                        with open(LOG_FILE, "r", encoding="utf-8") as f:
                            logs = json.load(f)
                            if not isinstance(logs, list):
                                logs = []
                    except Exception:
                        logs = []

                user = update.message.from_user
                logs.append({
                    "user": f"@{user.username or 'unknown'}",
                    "group_id": gid,
                    "content": sent_content
                })

                with open(LOG_FILE, "w", encoding="utf-8") as f:
                    json.dump(logs, f, ensure_ascii=False, indent=2)

            except Exception as e:
                print(f"âŒ Log write failed (ignored): {e}")

        except Exception as e:
            print(f"âŒ Failed to send to {gid}: {e}")
            failed += 1
            failed_groups.append(gid)

    result = f"âœ… Forward/Copy á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º: {success}\nâŒ á€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º: {failed}"
    if failed_groups:
        result += "\ná€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€á€²á€·á€á€Šá€·á€º Group ID á€™á€»á€¬á€¸:\n" + "\n".join(map(str, failed_groups))
    await update.message.reply_text(result)

def log_send(user_obj, group_id, content):
    """Append log safely with limit, including user_id and display name"""
    log_entry = {
        "user": user_obj.username or "",
        "user_id": user_obj.id,
        "name": user_obj.full_name or "Unknown",
        "group_id": group_id,
        "content": content
    }

    logs = []
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                logs = json.load(f)
                if not isinstance(logs, list):
                    logs = []
        except Exception:
            logs = []

    logs.append(log_entry)

    # Limit logs
    if len(logs) > MAX_LOGS:
        logs = logs[-MAX_LOGS:]

    try:
        with open(LOG_FILE, "w", encoding="utf-8") as f:
            json.dump(logs, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[ERROR] Log write failed: {e}")


# ===== Show Logs with ID check =====
async def show_send_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in OWNER_ID:  # OWNER_ID = [123456789, ...]
        await update.message.reply_text("â›” Owner only command")
        return

    if not os.path.exists(LOG_FILE):
        await update.message.reply_text("No logs found.")
        return

    try:
        with open(LOG_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            if not isinstance(data, list):
                await update.message.reply_text("Log file corrupted.")
                return
    except (json.JSONDecodeError, OSError):
        await update.message.reply_text("Log file corrupted or unreadable.")
        return

    if not data:
        await update.message.reply_text("No logs yet.")
        return

    # Show last 20 logs
    logs = data[-20:]
    messages = []
    for entry in logs:
        log_user_id = entry.get("user_id", 0)
        display_name = entry.get("name", "Unknown")
        group_id = entry.get("group_id", "?")
        content = entry.get("content", "")

        mention = f"[{display_name}](tg://user?id={log_user_id})"
        messages.append(f"{mention} âœ Group {group_id} : {content}")

    # Split into chunks
    MAX_LEN = 4000
    full_message = "\n".join(messages)
    chunks = [full_message[i:i+MAX_LEN] for i in range(0, len(full_message), MAX_LEN)]

    for chunk in chunks:
        try:
            await update.message.reply_text(chunk, parse_mode="Markdown")
        except Exception as e:
            print(f"[ERROR] Failed to send log message: {e}")
            await update.message.reply_text("âš  Some logs could not be displayed.")
            break


# ===== /speed Command =====
async def speed_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global attack_speed
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    if not is_admin_or_owner(user_id):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    if not context.args:
        await update.message.reply_text("Speed (seconds) á€€á€­á€¯ á€Šá€½á€¾á€”á€ºá€•á€¼á€•á€±á€¸á€•á€«")
        return

    try:
        val = float(context.args[0])
        if val < 0.2:
            await update.message.reply_text("Speed á€á€±á€¸á€œá€½á€”á€ºá€¸á€”á€±á€•á€«á€á€šá€ºá‹ á€¡á€”á€Šá€ºá€¸á€†á€¯á€¶á€¸ 0.3á€…á€€á€¹á€€á€”á€·á€ºá€‘á€¬á€¸á€•á€«")
            return
        if val > 1.2:
            await update.message.reply_text("Speed á€”á€¾á€±á€¸á€œá€½á€”á€ºá€¸á€á€šá€ºá€™á€¡á€±á€œá€­á€¯á€¸á€›á€±1.2á€‘á€­á€‘á€¬á€¸á€€á€¼á€•á€«")
            return

        attack_speed = val
        await update.message.reply_text(f"Attack speed á€€á€­á€¯ {attack_speed} á€…á€€á€¹á€€á€”á€·á€ºá€¡á€–á€¼á€…á€º á€á€á€ºá€™á€¾á€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
    except ValueError:
        await update.message.reply_text("Speed á€€á€­á€¯ á€”á€¶á€•á€«á€á€ºá€•á€²á€‘á€Šá€·á€ºá€•á€«")


# ===== /hell Command (Owner/Admin allowed) =====
async def hell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    target_raw = context.args[0].lstrip("@")
    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    # âœ… Owner protection for single OWNER_ID as int
    if target_id == OWNER_ID:
        await update.message.reply_text("á€¡á€›á€¾á€„á€ºá€á€á€„á€ºá€€á€­á€¯ á€™á€œá€½á€”á€ºá€†á€”á€ºá€”á€­á€¯á€„á€ºá€•á€«")
        return

    display_name = getattr(chat, "full_name", None) or getattr(chat, "first_name", "Unknown")
    attack_targets[target_id] = display_name
    await update.message.reply_text(f"Target User: {display_name} (ID: {target_id}) á€€á€­á€¯ attack á€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")


# ===== /stophell Command (Owner/Admin allowed) =====
async def stophell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        return

    target_raw = context.args[0].lstrip("@")
    try:
        if target_raw.isdigit():
            chat = await context.bot.get_chat(int(target_raw))
        else:
            chat = await context.bot.get_chat(target_raw)
    except Exception as e:
        await update.message.reply_text(f"á€á€½á€±á€¸á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    user_id = chat.id
    if user_id in attack_targets:
        del attack_targets[user_id]
        await update.message.reply_text(f"{getattr(chat, 'first_name', 'User')} á€†á€­á€¯á€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€±á€¸á€á€±á€¸á€œá€±á€¸á€€á€­á€¯á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€á€Šá€º")
    else:
        await update.message.reply_text(f"{getattr(chat, 'first_name', 'User')} á€€á€­á€¯hellá€™á€á€¯á€¶á€¸á€›á€á€±á€¸á€˜á€°á€¸á€™á€¡á€±á€œá€­á€¯á€¸")

# ===== Combined Message Handler =====
async def combined_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg:
        return

    chat_id = update.effective_chat.id
    sender = update.effective_user
    sender_id = sender.id

    # Hidden targets deletion
    if sender_id in hidden_targets:
        try:
            await msg.delete()
        except Exception as e:
            print(f"[Delete Failed] {sender_id}: {e}")

    # Fight session
    if chat_id in active_fight_sessions:
        session = active_fight_sessions[chat_id]
        if sender_id in session:
            target_id = session[sender_id]
            try:
                target_member = await context.bot.get_chat_member(chat_id, target_id)
            except Exception:
                return

            sender_mention = mention_html(sender.id, sender.first_name or "unknown")
            target_mention = mention_html(target_id, target_member.user.first_name or "unknown")
            reply_text = (
                f"{target_mention}\n"
                f"á€™á€„á€ºá€¸á€€á€­á€¯ {sender_mention} á€€ â€œ{msg.text or ''}â€ á€á€²á€·á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€á€šá€ºá‹"
            )
            await msg.reply_html(reply_text)
            return

    # Hell attack auto-reply
    if sender_id in attack_targets:
        display_name = attack_targets[sender_id]
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={sender_id})"
        reply_text = random.choice(auto_replies)
        try:
            await msg.reply_markdown_v2(f"{mention_text}\n{escape_markdown(reply_text, version=2)}")
        except Exception as e:
            print(f"[Hell Reply Failed] {e}")
        return

    # Auto-reply to attacking users
    username = sender.username
    if username and username.lower() in attacking_users.get(chat_id, set()):
        msg_text = random.choice(auto_replies)
        safe_msg = escape_markdown(msg_text, version=2)
        display_name = f"@{username}"
        try:
            await msg.reply_markdown_v2(f"{display_name}\n{safe_msg}")
        except Exception as e:
            print(f"[Auto Reply Failed] {e}")


# ===== /say COMMAND =====
async def say(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    if not context.args:
        await update.message.reply_text("Usage: /say message_text")
        return

    message_text = " ".join(context.args)
    await update.message.reply_text(message_text)


# ===== CLEAR UPDATE QUEUE =====
async def clear_update_queue(app):
    while not app.update_queue.empty():
        try:
            await app.update_queue.get()
        except Exception:
            break

# ===== /hide Command =====
async def hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not is_authorized(user_id):  # Owner/Admin check
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    target_id = None
    target_name = "Unknown"

    # Reply to a message
    if update.message.reply_to_message:
        target_user = update.message.reply_to_message.from_user
        target_id = target_user.id
        target_name = target_user.first_name or "Unknown"
    # ID or @username argument
    elif context.args:
        raw_arg = context.args[0].lstrip("@")
        if raw_arg.isdigit():
            target_id = int(raw_arg)
        else:
            try:
                chat = await context.bot.get_chat(raw_arg)
                target_id = chat.id
                target_name = getattr(chat, "first_name", getattr(chat, "full_name", "Unknown"))
            except Exception:
                await update.message.reply_text(f"âŒ Cannot find user: {raw_arg}")
                return

    # âœ… Owner/Admin protection using ADMINS set
    if target_id in ADMINS:
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸")
        return

    if target_id:
        hidden_targets.add(target_id)
        await update.message.reply_text(
            f"ğŸ”’ Hidden: <a href='tg://user?id={target_id}'>{target_name}</a>",
            parse_mode="HTML"
        )
    else:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
        

# ===== /stophide Command =====
async def stop_hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return

    target_id = None
    target_name = "Unknown"

    # Reply to a message
    if update.message.reply_to_message:
        target_user = update.message.reply_to_message.from_user
        target_id = target_user.id
        target_name = target_user.first_name or "Unknown"
    # ID or @username argument
    elif context.args:
        raw_arg = context.args[0].lstrip("@")
        if raw_arg.isdigit():
            target_id = int(raw_arg)
        else:
            try:
                chat = await context.bot.get_chat(raw_arg)
                target_id = chat.id
                target_name = getattr(chat, "first_name", getattr(chat, "full_name", "Unknown"))
            except Exception:
                await update.message.reply_text(f"âŒ Cannot find user: {raw_arg}")
                return

    # âœ… Owner/Admin protection using ADMINS set
    if target_id in ADMINS:
        await update.message.reply_text("âŒ Owner/Admin á€€á€­á€¯ unhide á€œá€¯á€•á€ºáá€™á€›á€•á€«á‹")
        return

    if target_id:
        hidden_targets.discard(target_id)
        await update.message.reply_text(
            f"âœ… Unhidden: <a href='tg://user?id={target_id}'>{target_name}</a>",
            parse_mode="HTML"
        )
    else:
        await update.message.reply_text("á€á€¯á€¶á€¸á€”á€Šá€ºá€¸á€á€­á€á€»á€„á€ºá€›á€„á€ºá€á€»á€”á€ºá€”á€šá€ºá€€á€…á€¬á€á€½á€±á€€á€­á€¯á€–á€á€ºá€…á€±á€¬á€€á€ºá€á€€á€º @Problem_Xz")
       
# ===== Upload (Owner only) =====
async def upload_reply_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sender = update.effective_user
    if not sender or not is_owner(sender.id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸")
        return

    # Check reply
    if not update.message.reply_to_message or not update.message.reply_to_message.document:
        await update.message.reply_text("âš ï¸ Reply to a file to upload.")
        return

    doc = update.message.reply_to_message.document
    file_name = doc.file_name

    # Only .py or .so
    if not file_name.endswith((".py", ".so")):
        await update.message.reply_text("âš ï¸ Only .py or .so files allowed.")
        return

    # Download file
    file = await doc.get_file()
    await file.download_to_drive(file_name)
    await update.message.reply_text(f"âœ… {file_name} downloaded. Replacing bot...")

    # Replace old bot file directly (no backup)
    current_file = sys.argv[0]
    os.replace(file_name, current_file)

    # Restart bot
    await update.message.reply_text("ğŸ”„ Restarting bot...")
    os.execv(sys.executable, ['python3'] + sys.argv)


# ===== Help (Owner & Admin) =====
def escape_md2(text: str) -> str:
    # MarkdownV2 reserved characters escape
    return re.sub(r'([_\*\[\]\(\)\~\`\>\#\+\-\=\|\{\}\.\!])', r'\\\1', text)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id

    if not is_authorized(user_id):
        await update.message.reply_text("á€á€¬á€¸á€á€¬á€¸á€á€»á€…á€ºá€á€²á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€á€°á€á€­á€¯á€¸á€á€½á€±á€›á€½á€¾á€±Botá€€á€­á€¯á€™á€‘á€­á€•á€«á€”á€²á€·á€•á€«á€™á€…á€ºá€œá€­á€¯á€á€»á€„á€ºá€›á€„á€º @Problem_Xz á€á€»á€”á€ºá€”á€šá€ºá€€á€­á€¯á€‚á€»á€­á€¯á€„á€ºá€¸á€•á€«á€á€°á€á€­á€¯á€¸á€™á€»á€¬á€¸á€™á€‘á€­á€›")
        return


    help_text = """
ğŸ“Œ *á€™á€°á€›á€„á€ºá€¸ Bot Commands*

/id
ğŸ“ á€á€°á€™á€»á€¬á€¸á€…á€¬á€€á€­á€¯á€‘á€±á€¬á€€á€ºá€•á€¼á€®á€¸á€›á€±á€¸á€›á€„á€º á€á€°á€·á€¡á€­á€¯á€„á€ºá€’á€®á€™á€¼á€„á€ºá€›á€™á€šá€ºá‹

/attack username or id
Username á€›á€¾á€­á€›á€„á€º Username á€”á€²á€· á€á€¯á€¶á€¸á€•á€«áŠ á€™á€›á€¾á€­á€›á€„á€º ID á€á€¯á€¶á€¸á€•á€«
á€›á€•á€ºá€á€»á€„á€ºá€›á€„á€º: /stop username or id (Example: /stop @username, /stop 123456789, /stop all)

/hell id (á€¡á€­á€¯á€„á€ºá€’á€®á€•á€­á€¯á€„á€ºá€›á€¾á€„á€ºá€…á€¬á€›á€±á€¸á€á€­á€¯á€„á€ºá€¸á€…á€¬á€‘á€±á€¬á€€á€ºá€†á€²)
á€›á€•á€ºá€á€»á€„á€ºá€›á€„á€º: /stophell id 

/funny id id
 Funny mode á€…á€á€„á€º (á€¡á€­á€¯á€„á€ºá€’á€®á€”á€¾á€…á€ºá€á€¯á€œá€­á€¯á€á€šá€º)
 á€›á€•á€ºá€á€»á€„á€ºá€›á€„á€º: /stopfunny id id
 Troll God Version: á€á€…á€ºá€šá€±á€¬á€€á€ºá€›á€±á€¸á€á€­á€¯á€„á€ºá€¸ Reply á€•á€¼á€”á€ºá€•á€¼á€®á€¸ á€”á€±á€¬á€€á€ºá€á€…á€ºá€šá€±á€¬á€€á€ºá€€á€­á€¯ á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€º ğŸ˜ˆ

/hide
 Reply á€œá€¯á€•á€ºá€•á€¼á€®á€¸ target á€…á€¬á€–á€»á€€á€º
 á€›á€•á€ºá€á€»á€„á€ºá€›á€„á€º: /stophide

Channel - @Problem_Xz
Good Luck Guys ğŸ˜
"""
    escaped_text = escape_md2(help_text)
    await update.message.reply_text(escaped_text, parse_mode="MarkdownV2")

# -----------------------------

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ¤– Bot á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€”á€±á€•á€«á€•á€¼á€®á‹")

# -----------

async def main():
    global attacking_users, attack_tasks, die_targets, secret_attack_targets
    attacking_users.clear()
    attack_tasks.clear()
    secret_attack_targets.clear()

    refresh_admins()
    global ADMINS
    ADMINS, _ = load_admins()

    app = ApplicationBuilder().token(TOKEN).build()

    # Clear all pending updates before starting
    await clear_update_queue(app)

    # Add command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("attack", attack))
    app.add_handler(CommandHandler("stop", stop))
    app.add_handler(CommandHandler("add_admin", add_admin))
    app.add_handler(CommandHandler("remove_admin", remove_admin))
    app.add_handler(CommandHandler("ban_admin", ban_admin))
    app.add_handler(CommandHandler("unban_admin", unban_admin))
    app.add_handler(CommandHandler("list_admins", list_admins))
    app.add_handler(CommandHandler("list_banned_admins", list_banned_admins))
    app.add_handler(CommandHandler("shutdown", shutdown))
    app.add_handler(CommandHandler("secret_attack", secret_attack))
    app.add_handler(CommandHandler("stop_secret_attack", stop_secret_attack))
    app.add_handler(CommandHandler("id", id_command))
    app.add_handler(CommandHandler("say", say))
    app.add_handler(CommandHandler("show", show))
    app.add_handler(CommandHandler("hide", hide))
    app.add_handler(CommandHandler("stophide", stop_hide))
    app.add_handler(CommandHandler("show_send_logs", show_send_logs))
    app.add_handler(CommandHandler("add_message", add_message))
    app.add_handler(CommandHandler("funny", funny_command))
    app.add_handler(CommandHandler("add_group", add_group))
    app.add_handler(CommandHandler("send", send_handler))
    app.add_handler(CommandHandler("stophell", stophell))
    app.add_handler(CommandHandler("show_messages", show_messages))
    app.add_handler(CommandHandler("speed", speed_command))
    app.add_handler(CommandHandler("stopfunny", stop_funny_command))
    app.add_handler(CommandHandler("hell", hell))
    app.add_handler(CommandHandler("limit", limit))
    app.add_handler(CommandHandler("upload", upload_reply_handler))
    app.add_handler(CommandHandler("name", set_name))
    app.add_handler(CommandHandler("shownames", show_names))
    app.add_handler(CommandHandler("listgp", list_groups))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, combined_message_handler))
    app.add_handler(MessageHandler(filters.ALL, track_group_id))
    app.add_handler(CommandHandler("gp_id", gp_id_command))

    await app.run_polling()


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
